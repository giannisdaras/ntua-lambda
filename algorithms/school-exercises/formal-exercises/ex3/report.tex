\documentclass[a4paper,oneside, 11pt]{article}
\usepackage[margin=0.7in]{geometry}
\usepackage[cm-default]{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}
\usepackage{xgreek}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{parallel,enumitem}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
\setmainfont[Mapping=tex-text]{CMU Serif}
\usepackage{graphicx}
\usepackage{color}
\usepackage{mathtools, amsmath}
\usepackage{float}
\usepackage{caption}
\usepackage{titling}
\usepackage{tikz}
\usepackage{algorithm2e}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}
\makeatletter
\def\maxwidth{%
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\makeatletter
\newcommand\xlongleftrightarrow[2][]{%
\ext@arrow 0059{\longleftrightarrowfill@}{#1}{#2}%
}
\def\longleftrightarrowfill@{%
\arrowfill@ ← \relbar → }
\makeatother




\pretitle{%
		\begin{center}
		\LARGE
		\includegraphics[height=7cm]{pyrforos.png}\\[\bigskipamount]
}
\posttitle{\end{center}}
\title{\textbf{Αλγόριθμοι \\ 3η Σειρά Γραπτών Ασκήσεων}}
\author{ Ιωάννης Δάρας (\texttt{03115018, el15018@central.ntua.gr, daras.giannhs@gmail.com}) \\
}
\date{
“Perhaps the most important principle for the good algorithm designer is to refuse to be content.” \\ —Alfred V. Aho}

\newtheorem{theorem}{Θεώρημα}
\begin{document}
\maketitle
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}

\section{Άσκηση 1}
\subsection{Διατύπωση αλγορίθμου}
Ο αλγόριθμος για την εύρεση του μακρύτερου μονοπατιού σε ένα δέντρο βασίζεται σε μια postorder διάσχιση του δέντρου. Για την άσκηση μας, postorder διάσχιση ενός δέντρου θεωρούμε ότι όταν θέλουμε να εξερευνήσουμε ένα υπόδεντρο, εξερευνούμε τελευταία τη ρίζα του υποδέντρου, δηλαδή πρώτα εξερευνούμε όλα τα παιδιά και στη συνέχεια τη ρίζα. Ξεκινάμε την ανάλυση του αλγορίθμου με ορισμένες παρατηρήσεις.\bigbreak 

Ορίζουμε ως $P(n)$ το κατηγόρημα να περνάει το μονοπάτι p, όπου p ένα τυχαίο μονοπάτι του δέντρου, από τον κόμβο n και $R(u,v)$ το κατηγόρημα που μας λέει ότι η κορυφή v είναι παιδί της κορυφής u. Τότε, για οποιοδήποτε μονοπάτι p σε ένα δέντρο ισχύει ένα από τα ακόλουθα:
\begin{enumerate}
\item 
$$\not \exists n \in V: P(n) \wedge P(u) \wedge P(v) \wedge R(n, u) \wedge R(n, v)$$
Δηλαδή δεν υπάρχει κορυφή που το μονοπάτι να περνάει από παραπάνω από ένα υπόδεντρα της.
\item 
Ορίζουμε ως T(n) το κατηγόρημα:
$$
T(n) =:= P(n) \wedge P(u) \wedge P(v) \wedge R(n, u) \wedge R(n, v)
$$
Τότε:
$$
\exists n \in V: T(n) \wedge \exists w \in V: T(w) \implies n=w
$$
Αυτό σημαίνει ότι υπάρχει μόνο μία κορυφή που ανήκει στο μονοπάτι και το μονοπάτι περνάει και από το αριστερό και από το δεξί της υπόδεντρο.
\end{enumerate}

Συνδυάζοντας τα 1. , 2. παίρνουμε ότι:

\begin{theorem}{Υπάρχει το πολύ 1 κορυφή που ένα μονοπάτι του δέντρου περνάει και από το αριστερό και από το δεξί της υπόδεντρο}
\end{theorem}
Αφού και το μακρύτερο μονοπάτι του δέντρου είναι και αυτό ένα μονοπάτι τότε και για αυτό θα ισχύει αυτή η ιδιότητα. Με βάση αυτή την παρατήρηση μπορούμε να υπολογίσουμε για κάθε κόμβο ποιό είναι το μεγαλύτερο προκύπτον μονοπάτι για τον κόμβο αυτό αν το μονοπάτι ξεκίναει (ή τελείωνει, όπως το δει κανείς) για τις ακόλουθες δύο επιλογές:
\begin{enumerate}
\item Το μονοπάτι που ξεκινάει από τον κόμβο δεν περνά από δύο υπόδεντρα του. \bigbreak

Τότε, το καλύτερο μονοπάτι για τον κόμβο είναι είτε το max από τα καλύτερα μονοπάτια των παιδιών του + την αξία του κόμβου, αν υπάρχει παιδί με θετικής αξίας καλύτερο μονοπάτι, είτε η αξία του κόμβου.

\item Το μονοπάτι περνά που ξεκινάει από τον κόμβο περνάει από δύο υπόδεντρα του. \bigbreak 

Τότε, το καλύτερο μονοπάτι για τον κόμβο είναι το καλύτερο μονοπάτι του καλύτερου υποδέντρου + την αξία του κόμβου + το καλύτερο μονοπάτι του δεύτερου καλύτερου υποδέντρου.
\end{enumerate}

Εφαρμόζοντας postorder διάσχιση, μπορούμε να υπολογίσουμε με προφανή τρόπο τα καλύτερα μονοπάτια για τα φύλλα και στη συνέχεια να υπολογίσουμε τα καλύτερα μονοπάτια των προγόνων παίρνοντας τα καλύτερα μονοπάτια των απογόνων που δεν έχουν διπλώσει (δηλαδή δεν περνάνε για κανέναν απόγονο από παραπάνω από ένα υπόδεντρο). \bigbreak 


Κατά τη διάρκεια της preorder διάσχισης μπορούμε να κρατάμε τις ακόλουθες πληροφορίες:
\begin{itemize}
\item Για κάθε κόμβο έναν πίνακα δύο θέσεων με τους απογόνους για κάθε μία από τις περιπτώσεις, δηλαδή για την περίπτωση που το μονοπάτι περνάει από παραπάνω από έναν άμεσο απόγονο και για την περίπτωση που το μονοπάτι περνάει μόνο από έναν άμεσο απόγονο.
\item Για κάθε κόμβο έναν πίνακα δύο θέσεων με τις τιμές του καλύτερου μονοπατιού για κάθε μία από τις περιπτώσεις.
\item Συνολικά, μια τιμή που αναπαριστά την αξία του καλύτερου μονοπατιού που έχουμε συναντήσει.
\item Συνολικά, έναν δείκτη στον κόμβο από τον οποίο "ξεκινά" το καλύτερο μονοπάτι που έχουμε συναντήσει.
\end{itemize}


Στο τέλος της postorder διάσχισης, μπορούμε μέσω του δείκτη στον κόμβο που έχει το καλύτερο μονοπάτι και ακολουθώντας τους πίνακες απογόνων των κόμβων να ανακτήσουμε το καλύτερο μονοπάτι.

\subsection{Ορθότητα αλγορίθμου}
Θα αποδείξουμε την ορθότητα του αλγορίθμου με επαγωγή. Υποθέτουμε ότι για έναν τυχαίο κόμβο του δέντρου έχουμε υπολογίσει ορθά το μακρύτερο μονοπάτι που μπορεί να ξεκινά για καθέναν από τους κόμβους παιδιά του (επαγωγική υπόθεση). Θα δείξουμε ότι και για αυτόν τον κόμβο μπορούμε να υπολογίσουμε το μακρύτερο μονοπάτι που ξεκινά από αυτόν. \bigbreak 

Αρχικά, αφού το μονοπάτι ξεκινάει από τον κόμβο προς εξέταση δεν μας ενδιαφέρει ο γονέας του συγκεκριμένου κόμβου. Οι κόμβοι που εξετάζουμε είναι οι κόμβοι παιδιά που έχουν ήδη υπολογιστεί από επαγωγική υπόθεση (optimal substructure property). \bigbreak 

Όπως αναλύσαμε και στην ενότητα διατύπωσης του αλγορίθμου, το μονοπάτι μπορεί είτε να περνάει από δύο υπόδεντρα του προς εξέταση κόμβου, είτε από ένα είτε από κανένα. Έστω $v_1, v_2$ οι δύο μεγαλύτερες αξίες των μονοπατιών των απογόνων που δεν έχουν διπλώσει και $w$ η αξία του προς εξέταση κόμβου. H αξία V του μακρύτερου μονοπατιού p που ξεκινάει από τον κόμβο αξίας w θα είναι:
$$
max(v_1 + w, v_2 + w, v_1 + v_2 + w, w)
$$
εφόσον άμα πάμε σε κάποιο από τα μονοπάτια θα περάσουμε από το προϋπολογισμένο μακρύτερο μονοπάτι + την αξία του κόμβου και αν το μονοπάτι "διπλώσει" θα περάσουμε από όλα. \bigbreak 

Ο αλγόριθμος μας ακολουθεί ακριβώς αυτό το κριτήριο και συνεπώς είναι ορθός.
\subsection{Πολυπλοκότητα λύσης}
Η πολυπλοκότητα της λύσης μας είναι η πολυπλοκότητα της αναζήτησης σε ένα δέντρο, δηλαδή: $O(V+E)$
\section{Άσκηση 2}
\subsection{(α)} 

\subsubsection{Διατύπωση αλγορίθμου}

Θα εκμεταλλευτούμε την ιδιότητα της τοπογραφικής ταξινόμησης που έχουν τα DAG γραφήματα. \bigbreak 

Αρχικά, ταξινομούμε τοπολογικά το γράφο. Για να ταξινομήσουμε τοπολογικά το γράφο κάνουμε DFS με μία στοίβα. Συγκεκριμένα, κατά την DFS διάσχιση χωρίζουμε τις κορυφές σε τρεις κατηγορίες: σε αυτές που δεν έχουμε ακόμα εξερευνήσει, αυτές που έχουμε μερικώς εξερευνήσει και αυτές που έχουμε εξερευνήσει τελείως. Αρχικά όλες οι κορυφές είναι ανεξερεύνητες. Διαλέγουμε μια τυχαία και κάνουμε DFS διάσχιση. Όταν συναντάμε κορυφές που δεν έχουμε ξαναδεί τις μεταφέρουμε στις μερικώς εξερευνημένες και πάμε να εξερευνήσουμε ένα από τα ανεξερεύνητα παιδιά της. Αν όλα τα παιδιά της είναι εξερευνημένα, τότε η κορυφή μεταφέρεται στις πλήρως εξερευνημένες και την εισάγουμε στη στοίβα. Συνεχίζουμε επαναληπτικά μέχρι να εξερευνηθούν όλες οι κορυφές. Στο τελος, εξάγουμε ένα ένα τα στοιχεία από τη στοίβα και παίρνουμε την τοπολογική ταξινόμηση του γράφου.  \bigbreak 

Αφού ολοκληρώσουμε την τοπολογική ταξινόμηση, βάζουμε αρχικά σε όλες τις κορυφές ως κόστος την τιμή της κορυφής τους. Στη συνέχεια,  ο αλγόριθμος μας επισκέπτεται μία μία τις κορυφές με την ανάποδη σειρά στην τοπολογική τους ταξινόμηση και κάνει τα αντίστοιχα updates στις κορυφές που έχουν ακμές προς αυτή. Τα updates γίνονται ως εξής: Έστω p(u) η τιμή μιας κορυφής u και κορυφές v, w που έχουν ακμές προς την κορυφή u και ως τώρα υπολογισμένα κόστη c(v), c(w) αντίστοιχα. Τότε:
$$
c(v) \gets min\left(c(v), c(u)\right)  , \quad c(w) \gets min\left(c(w), c(u)\right)$$

Σε μορφή ψευδοκώδικα: \bigbreak 
{\centering
\begin{minipage}{.7\linewidth}
\begin{algorithm}[H]
	$V \gets topological\_sort(G)$ \\
	\For{$v \in \textrm{reverse(V)}$}{
			$c(v) \gets p(v)$ \\
		\For{$u \in V : (u,v) \in E$}{
			\If{$c(v) < c(u)$}{$c(u) \gets c(v)$}
		}
	}
	\Return $c$
	\bigbreak
	\caption{{Cost function on DAG}}
\end{algorithm}
\end{minipage}
\par
}


\subsubsection{Απόδειξη ορθότητας}

Ο λόγος που ο αλγόριθμος μας δουλεύει είναι ότι υπάρχει το optimal substructure property. Διαισθητικά αυτό σημαίνει για την περίπτωση μας ότι κάθε φορά που ανανεώνουμε το κόστος μιας κορυφής u με βάση μια ακμή της προς μια κορυφή v, το κόστος της κορυφής v έχει ήδη υπολογιστεί σωστά. \bigbreak 

Αποδεικνύουμε την ορθότητα του αλγορίθμου μας αυστηρά μαθηματικά με επαγωγή. Έστω ότι έχουμε υπολογίσει σωστά τα κόστη των τελευταίων n κορυφών της τοπολογικής διάταξης. Θα δείξουμε ότι ο αλγόριθμος μας δίνει σωστό κόστος στην κορυφή n+1 από το τέλος της τοπολογικής διάταξης. \bigbreak 

Αρχικά, για τη συγκεκριμένη κορυφή γνωρίζουμε ότι έχει ακμές μόνο προς κορυφές που έχουν ήδη υπολογιστεί σωστά οι τιμές τους από επαγωγική υπόθεση, λόγω της τοπολογικής διάταξης. Αυτό μας δίνει το optimal substructure του προβλήματος. Ο αλγόριθμος μας εξέτασε αυτές τις ακμές όταν εξέτασε τις κορυφές στις οποίες οι ακμές καταλήγουν. Δεδομένου ότι όταν εξέταζε αυτές τις ακμές τα κόστη των κορυφών αυτών είχαν πάρει τη σωστή τιμή (από επαγωγική υπόθεση) παίρνοντας το min των κορυφών αυτών και ο προς εξέταση κόμβος θα πάρει τη σωστή τιμή. Συνεπώς, ο αλγόριθμος μας είναι ορθός.

\subsubsection{Πολυπλοκότητα}
Ο αλγόριθμος μας αρχικά φτιάχνει μια τοπολογική διάταξη του γράφου. Η τοπολογική διάταξη φτιάχνεται με DFS, δηλαδή έχει πολυπλοκότητα $O(V+E)$. Στη συνέχεια, εξετάζει όλες τις ακμές που εμπίπτουν σε μια κορυφή εξετάζοντας όλες τις κορυφές. Αυτή η πράξη έχει επίσης πολυπλοκότητα $O(V+E)$. Έτσι, η συνολική πολυπλοκότητα του αλγορίθμου μας είναι: $O(V+E)$.
\subsection*{(β)}

\subsubsection{Διατύπωση αλγορίθμου}
Ο αλγόριθμος μας βασίζεται στις ισχυρά συνεκτικές συνιστώσες του γράφου. Το πρώτο βήμα είναι να βρούμε τις ισχυρά συνεκτικές συνιστώσες. Για να το κάνουμε αυτό, χρησιμοποιούμε τον αλγόριθμο του Kosaraju's. Συγκεκριμένα, αρχικά εκτελούμε DFS μέχρι να ανακαλύψουμε όλες τις ακμές και χρησιμοποιούμε μια στοίβα για να αποθηκεύσουμε τη σειρά ανακάλυψης των ακμών, όπως ακριβώς κάναμε και στην τοπολογική ταξινόμηση. Στη συνέχεια, αντιστρέφουμε τη φορά όλων των ακμών στο γράφο και εκτελούμε στον καινούργιο γράφο πάλι DFS ξεκινώντας από την κορυφή που ανακαλύφθηκε τελευταία στην πρώτη DFS και συνεχίζοντας με τη σειρά που υπαγορευει η στοίβα ανακάλυψης ακμών. Για κάθε κορυφή από την οποία ξεκινάμε DFS στον καινούργιο γράφο, οι κορυφές που ανακαλύπτει είναι οι κορυφές του strongly connected component στο οποίο ανήκει. Κάνουμε τις κορυφές που ανακαλύφθηκαν visited και συνεχίζουμε με την επόμενη κορυφή της στοίβας για να βρούμε το επόμενο strongly connected component. \bigbreak 


Ο λόγος που χρησιμοποιομε τα strongly connected components είναι ότι κάθε κατευθυνόμενος γράφος είναι ένα DAG από τα strongly connected components του. Έτσι, μπορούμε αρχικά να φτιάξουμε μια κορυφή για κάθε  strongly connected component και να φτιάξουμε από τις ακμές $E$ τις ακμές $E^{'}$ για το νέο γράφο. Στο νεό γράφο, ο οποίος είναι dag, μπορούμε να τρέξουμε τον αλγόριθμο που περιγράψαμε στο βήμα (α). Τέλος, το μόνο που μένει να κάνουμε είναι να βάλουμε σε κάθε κορυφή την τιμή του strongly connected component στο οποίο ανήκει, η οποία υπολογιστήκε από τον αλγόριθμο του (α).

Σε μορφή ψευδοκώδικα: \bigbreak 
{\centering
\begin{minipage}{.7\linewidth}
\begin{algorithm}[H]
	\tcc{get strongly connected components }
	$G_1, G_2, ..., G_n \gets scc(G)$ \\ 
	\tcc{create graph of strongly connected components}
	$G' \gets create\_scc\_graph(G_1, G_2, ..., G_n, E)$ \\
	\tcc{run algorithm of (a)}
	$c \gets run\_a\_algorithm(G')$ \\
	\tcc{set cost of each vertex to the cost of the scc it belongs}
	$c \gets set\_cost(V, G', c)$ \\
	\Return $c$
	\bigbreak
	\caption{{Cost function on G}}
\end{algorithm}
\end{minipage}
\par
}


\subsubsection{Απόδειξη ορθότητας}

Για την απόδειξη ορθότητας πρέπει να αποδείξουμε τα ακόλουθα θεωρήματα:
\begin{theorem}
Κάθε γράφος μπορεί να μετατραπεί σε ένα dag από τα strongly connected components του.
\end{theorem}

Θα δουλέψουμε με άτοπο. Έστω ότι ο γράφος των strongly connected components δεν είναι dag, δηλαδή υπάρχει κύκλος. Αφού υπάρχει κύκλος μπορώ να πάω από το strongly component u σε ένα strongly component v και στη συνέχεια να ξαναγυρίσω στο strongly component u (πιθανώς και μέσω από άλλα strongly components w, t, p). Αφού μπορώ να το κάνω αυτό θα έπρεπε τα u,v να ανήκουν στο ίδιο strongly connected component αφού μπορώ από κάθε κορυφή του u να φτάσω σε κάθε κορυφή του v και αντίστροφα, άρα άτοπο. \bigbreak 

Συνεπώς, ο γράφος των strongly connected components είναι DAG.

\begin{theorem}
Κάθε κορυφή σε ένα strongly connected component έχει τo κόστος του strongly connected component.
\end{theorem}

Η απόδειξη της πρότασης αυτής είναι ευθεία. Το strongly connected component έχει το κόστος της μικρότερης κορυφής του καθώς αυτή συνδέεται με όλες τις άλλες κορυφές και άρα με όλες τις κορυφές που αυτές συνδέονται. Όμως αφού το component είναι strongly connected και όλες οι άλλες κορυφές συνδέονται με αυτή και αφού αυτή έχει το ελάχιστο κόστος στο component αυτές έχουν το κόστος αυτής. Άρα, όλες οι κορυφές σε ένα strongly connected component έχουν το ίδιο κόστος, το κόστος του component.
\bigbreak

Αφού αποδείξαμε τα παραπάνω δύο θεωρήματα, η ορθότητα του αλγορίθμου μας προκύπτει άμεσα από την ορθότητα του αλγορίθμου του (α) που έχουμε ήδη αποδείξει.
\subsubsection{Πολυπλοκότητα}

Αρχικά χωρίζουμε σε συνεκτικές συνιστώσες με τον αλγόριθμο του Kosaraju's. Για να το κάνουμε αυτό τρέχουμε δύο φορές DFS συνεπώς η πολυπλοκότητα της πράξης είναι: $O(V+E)$. Στη συνέχεια, φτιάχνουμε τον γράφο των strongly connected components. Ο γράφος αυτός έχει το πολύ V κορυφές και για να τον φτιάξουμε εξετάζουμε όλες τις ακμές, συνεπώς η πολυπλοκότητα κατασκευής του γράφου είναι: $O(V+E)$. Στη συνέχεια, τρέχουμε τον αλγόριθμο του ερωτήματος (α) με πολυπλοκότητα $O(V+E)$. Τέλος, για κάθε κορυφή δίνουμε το κόστος του strongly connected component στο οποίο ανήκει με πολυπλοκότητα $O(V)$. Έτσι, η συνολική πολυπλοκότητα του αλγορίθμου είναι:
$$O(V+E)$$




\section{Άσκηση 3}

\subsection{Minimax algorithm}
Προαπαιτούμενο για τη διατύπωση αλγορίθμου για τη συγκεκριμένη άσκηση είναι να διατυπώσουμε τον αλγόριθμο Minimax. Ο αλγόριθμος Minimax είναι ένας αλγόριθμος εύρεσης βέλτιστης ακολουθίας κινήσεων σε ένα παιχνίδι δύο παικτών που παίζεται σε γύρους. Κάθε κατάσταση του παιχνιδιού μοντελοποιείται ως ένας κόμβος ενός γράφου με ακμές προς όλες τις επόμενες δυνατές καταστάσεις του παιχνιδιού. Σε κάθε κόμβο του γράφου δίνεται μια τιμή από μια ευριστική συνάρτηση που δείχνει το "πόσο" νικάει ο παίκτης που παίζει πρώτος. Ο παίκτης που παίζει πρώτος προσπαθεί να μεγιστοποιήσει αυτή την τιμή ενώ ο παίκτης που παίζει δεύτερος προσπαθεί να την ελαχιστοποιήσει. Ο παίκτης που παίζει πρώτος διαλέγει να κάνει την κίνηση που θα τον οδηγήσει σε επόμενη κατάσταση που θα νικάει όσο το δυνατόν περισσότερο, δηλαδή διαλέγει πάντα από τις επόμενες καταστάσεις αυτή με το μεγαλύτερο σκορ. Αντίθετα, ο παίκτης που παίζει δεύτερος διαλέγει από τις επόμενες καταστάσεις αυτή με το λιγότερο σκορ προκειμένου να πετύχει το αντίθετο αποτέλεσμα.


\subsection{AB Pruning}
Μια γρηγορότερη παραλλαγή του αλγορίθμου Minimax είναι ο αλγόριθμος AB Pruning. Ο αλγόριθμος αυτός έχει πολυπλοκότητα χειρότερης περίπτωσης ίδια με τον αλγόριθμο Minimax και συνεπώς δεν τον εξετάζουμε στα πλαίσια αυτής της άσκησης. Τον αναφέρουμε μόνο για λόγους πληρότητας.


\subsection{Διατύπωση αλγορίθμου}
Το πρώτο πράγμα που κάνουμε είναι να φτιάξουμε ένα νέο γράφο $G^{'}(V^{'}, E^{'})$ ο οποίος να περιέχει ως καταστάσεις $V^{'}$ όλες τις τριάδες $i, j, k:i,j \in V, \ k \in [0,1]$ όπου το i είναι η κορυφή στην οποία βρίσκεται ο Κώστας, j η κορυφή στην οποία βρίσκεται ο Αντρέας και k δείχνει ποιος παίκτης παίζει, με k=0 να παίζει ο Κώστας. Αυτός ο γράφος έχει ως ακμές όλες τις επιτρεπτές μεταβάσεις που υπακούουν στους περιορισμούς του παιχνιδιού, δηλαδή όταν k=0 μετακινούμε το i σε γειτονική κορυφή από το γράφο G και όταν k=1 μετακινούμε το j σε γειτονική κορυφή από το γράφο G με την προϋπόθεση $j \neq d$. Αφού φτιάξουμε τις ακμές με τον τρόπο που αναφέραμε τρέχουμε αναζήτηση bfs από τον κόμβο που αρχίζει ο Κώστας και για κάθε κόμβο που συναντάμε σημειώνουμε τις τιμές $(a,b,c)$:
\begin{itemize}
\item a: μας δείχνει πόσο απέχει ο κόμβος από την κοντινότερη νίκη για το συγκεκριμένο παίκτη. \bigbreak 

Για τον Κώστα νίκη είναι να βρεθεί στο καταφύγιο ενώ για τον Αντρέα νίκη είναι να βρεθεί στην ίδια θέση με τον Κώστα.
\item b: μας δείχνει πόσο απέχει ο κόμβος από την κοντινότερη ήττα για το συγκεκριμένο παίκτη. \bigbreak

Για τον Κώστα ήττα είναι να βρεθεί σε ίδια θέση με τον Αντρέα ενώ για τον Αντρέα ήττα είναι να βρεθεί ο Κώστας στο καταφύγιο.
\item c: μας δείχνει πόσο απέχει ο κόμβος από την κοντινότερη ισοπαλία \bigbreak 

Η ισοπαλία ισοδυναμεί με εύρεση κύκλου στο γράφο, δηλαδή να βρούμε ακμή που να μας ξαναγυρίζει σε κάποια visited.
\end{itemize}
Αφού σημειώσουμε αυτές τις τιμές για τον κάθε κόμβο, κάνουμε άλλο ένα πέρασμα του γράφου και αυτή τη φορά επισημείωνουμε άλλες δύο τιμές t, p για τον κάθε κόμβο του γράφου ως εξής:
$$
t = b - a, \quad p = b - c
$$

Αφού κάνουμε αυτό εφαρμόζουμε τον αλγόριθμο του Minimax δύο φορές, μία για τον γράφο με τις επισημειώσεις t και μία με τον γράφο με τις επισημειώσεις p. Ο παίκτης Max είναι ο Κώστας που προσπαθεί να μεγιστοποιήσει το t, δηλαδή να απομακρύνει την ήττα του και να φέρει κοντά την νίκη του ενώ ο παίκτης Min είναι ο Αντρέας που προσπαθεί να ελαχιστοποιήσει το t, δηλαδή να πετύχει το αντίστροφο αποτέλεσμα. \bigbreak 

Στο τέλος, κάνουμε trace αρχικά τον Minimax για τον γράφο με τις επισημειώσεις t και βλέπουμε ποιά ακολουθία κινήσεων θα γίνει και ποιός τελικά θα κερδίσει. Αν δούμε ότι κερδίζει ο Αντρέας, τότε κάνουμε trace και τον Minimax στον γράφο με τις επισημειώσεις p προκειμένου να δούμε αν ο Κώστας με διαφορετική ακολουθία κινήσεων μπορεί να πετύχει ισοπαλία. \bigbreak 
\subsection{Πολυπλοκότητα}
\subsubsection{Κατασκευή γράφου}
Ο γράφος έχει $2V^2$ καταστάσεις και οι μεταβάσεις για κάθε κατάσταση υπολογίζονται σε $O(1)$. Έτσι, η συνολική πολυπλοκότητα για την κατασκευή του γράφου είναι: $O(V^2)$

\subsubsection{Επισημειώσεις a, b, c}
Για να επισημειώσουμε κάθε κόμβο του γράφου με a, b, c πρέπει να τρέξουμε μια BFS τον κόμβο που ξεκινά ο Κώστας. Η πολυπλοκότητα της BFS για γράφο με $V^2$ κορυφές και $\approx E^2$ ακμές είναι:
$$O(V^2 + E^2)$$. \bigbreak


\subsubsection{Minimax}
Ο minimax κάνει μια διάσχιση του γράφου, συνεπώς έχει πολυπλοκότητα: $O(V^2 + E^2)$. \bigbreak


Από τα παραπάνω, προκύπτει ότι η συνολική πολυπλοκότητα του αλγορίθμου μας είναι:
$$O(V^2 + E^2)$$

\subsection{Ορθότητα αλγορίθμου} 
Η ορθότητα του συγκεκριμένου αλγορίθμου προκύπτει από τα ακόλουθα :
\begin{enumerate}
\item Συνέπεια ευριστικής συνάρτησης για τους δύο παίκτες. \bigbreak 

Δεδομένου ότι η ευριστική συνάρτηση είναι η διαφορά μεταξύ της απόστασης νίκης του ενός και της απόστασης νίκης του άλλου, υπάρχει συνέπεια στην τιμή της ευριστικής σχετικά με την κατάσταση του παιχνιδιού.

\item Εξαντλητικός χώρος αναζήτησης \bigbreak 

Ο χώρος αναζήτησης είναι εξαντλητικός καθώς ο γράφος περιέχει όλες τις πιθανές καταστάσεις και η αναζήτηση είναι αναζήτηση bfs που σημαίνει ότι όλοι οι προσπελάσιμοι κόμβοι θα εξερευνηθούν.

\item Στρατηγική ισοπαλίας \bigbreak

Ο αλγόριθμος μας λαμβάνει υπόψιν το ότι άμα ένας παίκτης δεν μπορεί να κερδίσει πρέπει να θέσει ως στόχο την ισοπαλία και όχι τη νίκη (Minimax 2).
\end{enumerate}

Από τα παραπάνω και από την ορθότητα του αλγορίθμου Minimax προκύπτει άμεσα ότι και ο δικός μας αλγόριθμος οδηγεί στη βέλτιστη λύση.
\section{Άσκηση 4}
\subsection{(α)}
\subsubsection{Απόδειξη ύπαρξης ακμής}
Αρχικά, θα αποδείξουμε την ύπαρξη της ακμής $e^{'}$. Έστω ότι η ακμή e συνδέει δύο κορυφές a, b. Αν βγάλουμε την ακμή e από το spanning tree $T_1$ τότε τα a, b ανήκουν πλέον σε δύο ξένες συνεκτικές συνιστώσες, ας τις ονομάσουμε $G_1, G_2$. Στο spanning tree $T_2$ οι συνεκτικές συνιστώσες αυτές συνδέονται με μια ακμή $e^{'}$. Αν $e^{'} \in T_1$ τότε θα υπάρχουν δύο μονοπάτια από το a στο b, ένα απευθείας μέσω της ακμής $e$ και ένα μέσω ενδιάμεσων κορυφών που συνδέεουν τελικά τις δύο συνεκτικές συνιστώσες $G_1, G_2$ μέσω της ακμής $e^{'}$. Όμως, σε κάθε δέντρο, δύο οποιεσδήποτε κορυφές συνδέονται με μοναδικό μονοπάτι. Άρα, οδηγούμαστε σε άτοπο, δηλαδή $e^{'}\not \in T_1$.  \bigbreak 

\subsubsection{Απόδειξη συνεκτικότητας}
Αφού αποδείξαμε την ύπαρξη της ακμής $e^{'}$ μπορούμε με ευθεία απόδειξη να δείξουμε ότι το νέο δέντρο $T_1 \textrm{ \textbackslash  }\  \{e\} \cup \{ e^{'}\}$ είναι συνεκτικό. Πιο ειδικά, η ακμή $e^{'}$ όπως εξηγήσαμε συνδέει τις συνεκτικές συνιστώσες $G_1, G_2$ που αποσυνδέθηκαν λόγω της αφαίρεσης της ακμής $e$. Η προσθήκη μιας ακμής που συνδέει δύο ασύνδετες συνεκτικές συνιστώσες δεν μπορεί να προκαλέσει κύκλο καθώς δεν υπάρχει τρόπος επιστροφής από την $G_2$ στην $G_1$ πέρα από την ακμη που προστέθηκε. Άρα το προκύπτον γράφημα είναι και συνεκτικό και ακυκλικό (και προφανώς μένει δέντρο), άρα έχουμε ένα συνδετικό δέντρο.
\subsubsection{Αλγόριθμος εύρεσης μιας τέτοιας ακμής}
Ο τρόπος να βρούμε μια τέτοια ακμή είναι αρκετά προφανής. Αρχικά, αφαιρόντας την ακμή e εξηγήσαμε ότι το έχουμε δύο ξένες συνεκτικές συνιστώσες $G_1, G_2$. Για κάθε μία από τις κορυφές του $G_1$ εξετάζουμε αν υπάρχει ακμή προς το $G_2$ στο γράφο $G$. Όταν βρούμε μια τέτοια ακμή διαφορετική της $e$ τότε βρήκαμε την $e^{'}$ που ψάχναμε. 

\subsubsection{Πολυπλοκότητα αλγορίθμου}
Ο αλγόριθμος που περιγράψαμε απλά προσπελαύνει ακμές και κορυφές, που σημαίνει ότι είναι γραμμικός, δηλαδή έχει πολυπλοκότητα: $O(V+E)$

\subsection{(β)}
\subsubsection{Συνεκτικότητα γραφήματος H}
Το ερώτημα (α) μας έδωσε έναν μηχανισμό παραγωγής συνδετικών δέντρων. Συγκεκριμένα, μας έδωσε έναν τρόπο να ξεκινήσουμε από ένα συνδετικό δέντρο $T_1$ και αλλάζοντας μία ακμή τη φορά να πάμε σε ένα συνδετικό δέντρο $T_2$. \bigbreak 

\begin{theorem}{Όλα τα συνδετικά δέντρα έχουν τον ίδιο αριθμό ακμών}
\bigbreak 
\textbf{Απόδειξη θεωρήματος} \par 
Κάθε δέντρο $|V|$ κόρυφών έχει $|V-1|$ ακμές. Κάθε συνδετικό δέντρο έχει όλες τις κορυφές (αφού είναι συνδετικό), άρα έχει $V$ κορυφές και συνεπώς $|V-1|$ ακμές.
\end{theorem}

Αφού όλα τα συνδετικά δέντρα έχουν τον ίδιο αριθμό ακμών, χρησιμοποιώντας τον μηχανισμό του (α) μπορούμε ανταλλάσσοντας ακμές να πάμε από οποιοδήποτε συνδετικό δέντρο σε οποιοσδήποτε συνδετικό δέντρο. Κάθε φορά ανταλλάσσουμε μια ακμή και συνεπώς πάμε σε κάποιον γείτονα μας στο γράφημα H. Άρα, το γράφημα H είναι συνεκτικό.

\subsubsection{Μήκος συντομότερου μονοπατιού στο H}
Εξηγήσαμε ότι είναι εφικτό να πάμε από ένα συνδετικό δέντρο $T_1$ σε ένα οποιοδήποτε συνδετικό δέντρο $T_2$ αλλάζοντας 1 ακμή τη φορά. Στο γράφημα H οι μεταβάσεις είναι όλες μεταβάσεις 1 ακμής διαφοράς. Άρα, το να καταφέρουμε να πάμε από ένα συνδετικό δέντρο $T_1$ στο $T_2$, αν το $T_1$ έχει k διαφορετικές ακμές από το συνδετικό δέντρο $T_2$, αλλάζοντας 1 ακμή τη φορά είναι το συντομότερο μονοπάτι που μπορούμε να βρούμε στο γράφο H και δείξαμε ότι με το μηχανισμό του (α) ένα τέτοιο μονοπάτι υπάρχει. Άρα, το συντομότερο μονοπάτι μεταξύ $T_1, T_2$ έχει μήκος:
$$ |T_1 \textrm{\textbackslash } \  T_2|$$

\subsubsection{Αλγόριθμος εύρεσης συντομότερου μονοπατιού στο H}
Για να βρούμε τον συντομότερο μονοπάτι στο H χρησιμοποιούμε τον αλγόριθμο που μας δίνει το βήμα (α). Πιο συγκεκριμένα, βρίσκουμε $k$ του $T_1$ που δεν υπάρχουν στο $T_2$ και αντίστοιχα $k$ ακμές του $T_2$ που δεν υπάρχουν στο $T_1$. Σε χρόνο $O(E+V)$ φτιάχνουμε το συνδετικό δέντρο του (α), δηλαδή αφαιρούμε μια ακμή από τις k που δεν υπάρχει στο $T_2$ και υπάρχει στο $T_1$ και την αντικαθιστούμε με μια ακμή από τις άλλες k που υπάρχει στο $T_2$ και δεν υπάρχει στο $T_1$. Έτσι, προκύπτει ένα δέντρο $T_1^{'}$. Συνεχίζουμε με τις υπόλοιπες $k-1$ ακμές την ίδια διαδικασία για το προκύπτον δέντρο επαναληπτικά μέχρι να φτάσουμε στο $T_2$. Σε κάθε βήμα, μεταβαίνουμε στο δέντρο του H που ταιριάζει με το προκύπτον συνεκτικό δέντρο.


\subsection{(γ)}
\subsection{Διατύπωση αλγορίθμου}
Η λύση μας είναι απλή: φτιάχνουμε δύο συνεκτικά δέντρα $T_1, T_2$   όπου το $T_1$ έχει όσο περισσότερες ακμές γίνεται από το $E_1$ και το $T_2$ έχει όσες περισσότερες ακμές γίνεται από το $E_2$.
Η λύση μας βασίζεται στον αλγόριθμο union-find. \bigbreak Πιο ειδικά, για το πρώτο δέντρο ξεκινάμε από έναν γράφο χωρίς ακμές και με κορυφές τις V. Στη συνέχεια, ιεραρχούμε τις ακμές, βάζοντας πρώτα τις ακμές του συνόλου $E_1$ και στη συνέχεια τις ακμές του συνόλου $E_2$. Για κάθε μία ακμή του συνόλου εξετάζουμε (operation find) αν σχηματίζει κύκλο. Αν δεν σχηματίζει κύκλο, την προσθέτουμε στο γράφημα μας (operation union). Επαναλαμβάνουμε μέχρι να σχηματίσουμε συνεκτικό δέντρο $T_1$. \bigbreak 

Στη συνέχεια, ιεραρχούμε τις ακμές με ανάποδη σειρά και τρέχουμε πάλι τον ίδιο αλγόριθμο για να σχηματίσουμε δέντρο $T_2$. \bigbreak

Είναι φανερό ότι το $T_1$ έχει όσο πιο πολλές $E_1$ ακμές γίνεται ενώ το $T_2$ όσο πιο πολλές $E_2$ ακμές γίνεται. Έστω ότι το $T_1$ έχει $k_1$ ακμές του συνόλου $E_1$ και το $T_2$ έχει $k_2$ ακμές του συνόλου $E_1$. Διακρίνουμε τις ακόλουθες περιπτώσεις:
\begin{enumerate}
\item 
$$k_2 > k$$
Τότε το πρόβλημα μας δεν λύνεται.
\item 
$$k_1 < k$$
Επίσης το πρόβλημα μας δεν λύνεται.
\item 
$$k_2 < k < k_1$$
Στην περίπτωση αυτή το πρόβλημα μας λύνεται προσπαθώντας να προσεγγίσουμε το δέντρο $T_2$ από το δέντρο $T_1$ ανταλλάσοντας 1 ακμή τη φορά μέχρι να φτάσουμε σε συνεκτικό δέντρο k ακμών στο σύνολο $E_1$, με τον αλγόριθμο που είδαμε στο ερώτημα (α).
\end{enumerate} 

\subsubsection{Πολυπλοκότητα}
Αν υλοποιήσουμε το union find με weighted quick union και path compression όπως περιγράφεται στο [6] για την κατασκευή των δύο δέντρων θέλουμε πολυπλοκότητα: $O(E + Vlog^*E)$. Στη συνέχεια, για να πάμε από το ένα δέντρο στο άλλο θέλουμε πολυπλοκότητα χειρότερης περίπτωσης $O\left(k\cdot (V+E) \right)$ αφού το πολύ k αλλαγές θα γίνουν μέχρι να φτάσουμε στο ιδανικό δέντρο. Έτσι, η συνολική πολυπλοκότητα είναι:
$$O\left( k\cdot (V+E) + E + Vlog^*E\right)$$

\section{Άσκηση 5}
\subsection{(α)}
Έστω το γράφημα:
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (8.6,-12.8) circle (3);
\draw (8.6,-12.8) node {$a$};
\draw [black] (32.6,-12.7) circle (3);
\draw (32.6,-12.7) node {$b$};
\draw [black] (56.6,-12.8) circle (3);
\draw (56.6,-12.8) node {$c$};
\draw [black] (56.1,-35.3) circle (3);
\draw (56.1,-35.3) node {$d$};
\draw [black] (53.22,-36.137) arc (-76.05496:-154.63739:37.955);
\fill [black] (53.22,-36.14) -- (52.32,-35.84) -- (52.56,-36.82);
\draw (25.85,-34.12) node [below] {$100$};
\draw [black] (11.6,-12.79) -- (29.6,-12.71);
\fill [black] (29.6,-12.71) -- (28.8,-12.22) -- (28.8,-13.22);
\draw (20.6,-13.26) node [below] {$10$};
\draw [black] (35.6,-12.71) -- (53.6,-12.79);
\fill [black] (53.6,-12.79) -- (52.8,-12.28) -- (52.8,-13.28);
\draw (44.6,-13.26) node [below] {$10$};
\draw [black] (56.53,-15.8) -- (56.17,-32.3);
\fill [black] (56.17,-32.3) -- (56.68,-31.51) -- (55.68,-31.49);
\draw (55.82,-24.05) node [left] {$10$};
\draw [black] (56.17,-32.3) -- (56.53,-15.8);
\fill [black] (56.53,-15.8) -- (56.02,-16.59) -- (57.02,-16.61);
\draw [black] (53.6,-12.79) -- (35.6,-12.71);
\fill [black] (35.6,-12.71) -- (36.4,-13.22) -- (36.4,-12.22);
\draw [black] (29.6,-12.71) -- (11.6,-12.79);
\fill [black] (11.6,-12.79) -- (12.4,-13.28) -- (12.4,-12.28);
\draw [black] (53.215,-36.121) arc (-76.36843:-154.32392:38.193);
\fill [black] (9.79,-15.55) -- (9.69,-16.49) -- (10.59,-16.06);
\end{tikzpicture}
\end{center}


Έχει μοναδικό ΕΣΔ:
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (8.6,-12.8) circle (3);
\draw (8.6,-12.8) node {$a$};
\draw [black] (32.6,-12.7) circle (3);
\draw (32.6,-12.7) node {$b$};
\draw [black] (56.6,-12.8) circle (3);
\draw (56.6,-12.8) node {$c$};
\draw [black] (56.1,-35.3) circle (3);
\draw (56.1,-35.3) node {$d$};
\draw [black] (11.6,-12.79) -- (29.6,-12.71);
\fill [black] (29.6,-12.71) -- (28.8,-12.22) -- (28.8,-13.22);
\draw (20.6,-13.26) node [below] {$10$};
\draw [black] (35.6,-12.71) -- (53.6,-12.79);
\fill [black] (53.6,-12.79) -- (52.8,-12.28) -- (52.8,-13.28);
\draw (44.6,-13.26) node [below] {$10$};
\draw [black] (56.53,-15.8) -- (56.17,-32.3);
\fill [black] (56.17,-32.3) -- (56.68,-31.51) -- (55.68,-31.49);
\draw (55.82,-24.05) node [left] {$10$};
\draw [black] (56.17,-32.3) -- (56.53,-15.8);
\fill [black] (56.53,-15.8) -- (56.02,-16.59) -- (57.02,-16.61);
\draw [black] (53.6,-12.79) -- (35.6,-12.71);
\fill [black] (35.6,-12.71) -- (36.4,-13.22) -- (36.4,-12.22);
\draw [black] (29.6,-12.71) -- (11.6,-12.79);
\fill [black] (11.6,-12.79) -- (12.4,-13.28) -- (12.4,-12.28);
\end{tikzpicture}
\end{center}
Άρα, το αντίστροφο δεν ισχύει.
\subsection{(β)}
\subsubsection{Απόδειξη}
Θα δούλεψουμε με επαγωγή σε άτοπο. Έστω ότι για ένα γράφημα G που για κάθε τομή η ακμή ελάχιστου βάρους είναι μοναδική έχει δύο ελάχιστα συνδετικά δέντρα. Ας υποθέσουμε, χωρίς βλάβη της γενικότητας ότι τα συνδετικά αυτά δέντρα διαφέρουν μόνο σε μία ακμή, ας πούμε την ακμή $e = (u,v)$. Αν τα συνδετικά δέντρα απέχουν περισσότερες ακμές, μπορούμε να ανάξουμε το πρόβλημα στη διαφορά μίας ακμής χρησιμοποιώντας το μηχανισμό παραγωγής ελάχιστων συνδετικών δέντρων που εξηγήσαμε στην άσκηση 4 στα ερωτήματα (α), (β). \bigbreak 

Αφαιρούμε από το $T_1$ την ακμή $e$. Έτσι, το συνδετικό δέντρο γίνεται δάσος και σπάει σε δύο συνιστώσες $G_1, G_2$. Θεωρούμε την τομή $(G_1, G - G_1)$ του γράφου. Οι ακμές που μας πηγαίνουν από τη μία συνιστώσα της τομής στην άλλη έχουν διάφορα βάρη w. Παρόλα αυτά, η ακμή ελάχιστου βάρους είναι μοναδική από την υπόθεση μας για το γράφο G. Άρα, οποιαδήποτε ακμή και αν επιλέξουμε εκτός της e θα οδηγηθούμε σε συνδετικό δέντρο μεγαλύτερου συνολικού κόστους, άρα άτοπο. \bigbreak 

Από τα παραπάνω προκύπτει πως αν για κάθε τομή του γράφου G η ακμή ελάχιστου βάρους είναι μοναδική, τότε ο γράφος έχει μοναδικό ΕΣΔ.
\subsubsection{Αντιπαράδειγμα}
\bigbreak 
Έστω ο ακόλουθος γράφος:
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (22.6,-13.9) circle (3);
\draw (22.6,-13.9) node {$c$};
\draw [black] (52,-13.9) circle (3);
\draw (52,-13.9) node {$d$};
\draw [black] (37.8,-36.5) circle (3);
\draw (37.8,-36.5) node {$b$};
\draw [black] (36.13,-34.01) -- (24.27,-16.39);
\fill [black] (24.27,-16.39) -- (24.31,-17.33) -- (25.14,-16.77);
\draw [black] (39.4,-33.96) -- (50.4,-16.44);
\fill [black] (50.4,-16.44) -- (49.55,-16.85) -- (50.4,-17.38);

\draw (45.53,-26.5) node [right] {$1$};
\draw [black] (50.4,-16.44) -- (39.4,-33.96);
\fill [black] (39.4,-33.96) -- (40.25,-33.55) -- (39.4,-33.02);
\draw [black] (25.6,-13.9) -- (49,-13.9);
\fill [black] (49,-13.9) -- (48.2,-13.4) -- (48.2,-14.4);
\draw [black] (49,-13.9) -- (25.6,-13.9);
\fill [black] (25.6,-13.9) -- (26.4,-14.4) -- (26.4,-13.4);
\draw (37.3,-13.4) node [above] {$2$};
\draw [black] (24.27,-16.39) -- (36.13,-34.01);
\fill [black] (36.13,-34.01) -- (36.09,-33.07) -- (35.26,-33.63);
\draw (29.59,-26.54) node [left] {$1$};

\end{tikzpicture}
\end{center}
Ο γράφος αυτός μπορεί να χωριστεί σε δύο ξένες συνεκτικές συνιστώσες: $\{c, d\}, \{ b\}$ με τις ακμές της τομής να είναι οι : $(b,c), (b,d)$. Οι ακμές αυτές έχουν ίδιο βάρος, παρόλα αυτά το ελάχιστο συνδετικό δέντρο είναι μοναδικό:

\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (22.6,-13.9) circle (3);
\draw (22.6,-13.9) node {$c$};
\draw [black] (52,-13.9) circle (3);
\draw (52,-13.9) node {$d$};
\draw [black] (37.8,-36.5) circle (3);
\draw (37.8,-36.5) node {$b$};
\draw [black] (36.13,-34.01) -- (24.27,-16.39);
\fill [black] (24.27,-16.39) -- (24.31,-17.33) -- (25.14,-16.77);
\draw [black] (39.4,-33.96) -- (50.4,-16.44);
\fill [black] (50.4,-16.44) -- (49.55,-16.85) -- (50.4,-17.38);
\draw (45.53,-26.5) node [right] {$1$};
\draw [black] (50.4,-16.44) -- (39.4,-33.96);
\fill [black] (39.4,-33.96) -- (40.25,-33.55) -- (39.4,-33.02);
\draw [black] (24.27,-16.39) -- (36.13,-34.01);
\fill [black] (36.13,-34.01) -- (36.09,-33.07) -- (35.26,-33.63);
\draw (29.59,-26.54) node [left] {$1$};
\end{tikzpicture}
\end{center}


\subsection{(γ)}
Η ικανή και αναγκαία συνθήκη που προτείνουμε είναι η ακόλουθη:
\begin{theorem}
Έστω ένας γράφος G και $T_1, T_2, ..., T_n$ το σύνολο όλων των δυνατών συνδετικών δέντρων του γράφου. Αν 
$\exists i: Cost(T_i) < Cost(T_j) \forall j \neq i$ τότε το ελάχιστο συνδετικό δέντρο είναι μοναδικό.
\end{theorem}

\subsubsection{Ικανή συνθήκη}
Αν υπάρχει μοναδικό συνδετικό δέντρο με ελάχιστο κόστος τότε από ορισμό το ελάχιστο συνδετικό δέντρο είναι μοναδικό.  Συνεπώς, η συνθήκη που διατυπώσαμε είναι ικανή.

\subsubsection{Αναγκαία συνθήκη}
Έστω ότι $\exists T_i, T_j : Cost(T_i) = Cost(T_j)$. Και τα δύο δέντρα είναι συνδετικά δέντρα του γράφου G και αφού έχουν ίδιο κόστος είναι και τα δύο ελάχιστα συνδετικά δέντρα, άτοπο. Συνεπώς, η συνθήκη που διατυπώσαμε είναι αναγκαία.

\subsection{(δ)}
\subsection{Διατύπωση αλγορίθμου}
Αρχικά, φτιάχνουμε ένα συνδετικό δέντρο με τον αλγόριθμο του Kruskal. Στη συνέχεια, τρέχουμε ξανά τον αλγόριθμο του Kruskal και στις ισοπαλίες δοκιμάζουμε τελευταίες τις ακμές που βάλαμε στο συνδετικό δέντρο που κατασκευάσαμε προηγμένως. Αν οδηγηθούμε στο ίδιο συνδετικό δέντρο τότε το συνδετικό δέντρο είναι μοναδικό. 
\subsubsection{Ορθότητα αλγορίθμου}
Η ορθότητα του αλγορίθμου μας βασίζεται στην ικανότητα του αλγορίθμου Kruskal να βρεί όλα τα συνδετικά δέντρα ανάλογα με το πως χειρίζεται τις ισοπαλίες. Βάζοντας τελευταίες ανάμεσα στις ισοδύναμες ακμές τη δεύτερη φορά τις ακμές που βάλαμε στο συνδετικό δέντρο της πρώτης φοράς, πρακτικά, δοκιμάζουμε να φτιάξουμε κάθε άλλο δυνατό ελάχιστο συνδετικό δέντρο πριν φτιάξουμε το ελάχιστο συνδετικό δέντρο της πρώτης φοράς. Αν δεν υπάρχει άλλο δυνατό συνδετικό δέντρο, τότε φτιάχνουμε τελικά το συνδετικό δέντρο της πρώτης φοράς. \bigbreak 


Αυτή η ιδιότητα του αλγορίθμου του Kruskal μας εξασφαλίζει με ευθεία απόδειξη την ορθότητα του αλγορίθμου μας.


\subsection{Πολυπλοκότητα}

Η πολυπλοκότητα του αλγορίθμου μας είναι η πολυπλοκότητα του αλγορίθμου Kruskal, δηλαδή $O(ElogE)$.


\section{Βιβλιογραφία}
\noindent [1] Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2001), Introduction to Algorithms \par 
\noindent [2] Dial, Robert B. (1969). "Algorithm 360: Shortest-path forest with topological ordering", Communications of the ACM. \par 
\noindent [3]  Beineke, Lowell W.; Wilson, Robin J. (2009), Topics in topological graph theory, Encyclopedia of Mathematics and its Applications, 128, Cambridge University Press, Cambridge, p. 36 \par 
\noindent [4] Gross, Jonathan L.; Yellen, Jay (2005), Graph Theory and Its Applications (2nd ed.) \par 
\noindent [5] Russell, Stuart; Norvig, Peter (2003) [1995]. Artificial Intelligence: A Modern Approach (2nd ed.). Prentice Hall  \par 
\noindent [6] \href{https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf}{Princeton Union Find Presentation}
\end{document}